<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Delay Cam</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f141a; --border:#1f2a37;
      --text:#e6edf3; --muted:#9aa4b2; --btn:#121a24; --btnOn:#1a2635;
      --radius:16px;
    }
    *{box-sizing:border-box}
    body{margin:0;padding:12px;background:var(--bg);color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    .wrap{max-width:980px;margin:0 auto;display:flex;flex-direction:column;gap:12px}
    .bar{
      background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);
      padding:12px;display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;
    }
    .left,.right{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    button{
      appearance:none;border:1px solid var(--border);background:var(--btn);color:var(--text);
      border-radius:14px;padding:14px 16px;min-height:48px;min-width:120px;
      font-size:clamp(14px,2.2vw,18px);line-height:1;touch-action:manipulation;
    }
    button.on{background:var(--btnOn)}
    button.icon{min-width:56px;padding:14px 0;text-align:center}
    button:active{transform:translateY(1px)}
    button:disabled{opacity:.55}

    .pill{
      border:1px solid var(--border);border-radius:999px;padding:10px 12px;min-height:48px;
      display:flex;align-items:center;color:var(--muted);font-size:clamp(12px,2vw,15px);
    }

    .stage{
      background:#000;border:1px solid var(--border);border-radius:var(--radius);
      overflow:hidden;position:relative;
    }
    canvas{width:100%;height:auto;display:block;background:#000}
    video{display:none}

    .modalBack{
      position:fixed;inset:0;background:rgba(0,0,0,.55);
      display:none;align-items:flex-end;justify-content:center;padding:12px;
    }
    .modalBack.show{display:flex}
    .modal{
      width:min(860px,100%);background:var(--panel);border:1px solid var(--border);
      border-radius:18px;overflow:hidden;
    }
    .modalHeader{
      display:flex;align-items:center;justify-content:space-between;
      padding:12px;border-bottom:1px solid var(--border);
    }
    .modalTitle{color:var(--text);font-size:16px;opacity:.95}
    .modalBody{padding:12px;display:flex;flex-direction:column;gap:12px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    label{color:var(--muted);font-size:14px}
    input[type="range"]{width:min(520px,78vw)}
    select{
      background:var(--btn);color:var(--text);border:1px solid var(--border);
      border-radius:12px;padding:12px;min-height:44px;font-size:14px;
    }
    .smallBtn{min-width:160px}
    .hint{color:var(--muted);font-size:13px;line-height:1.35}

    .heatWrap{
      background:#0a0e13;border:1px solid var(--border);border-radius:14px;overflow:hidden;width:100%;
    }
    #heatView{
      width:100%;
      height:min(70vh, 720px);
      display:block;
      background:#0a0e13;
      touch-action: manipulation;
    }

    .overlayTip{
      position:absolute;left:10px;right:10px;bottom:10px;
      background:rgba(15,20,26,.88);border:1px solid rgba(31,42,55,.95);
      padding:10px 12px;border-radius:14px;color:var(--text);font-size:14px;
      display:none;
    }
    .overlayTip.show{display:block}
  </style>
</head>
<body>
<div class="wrap">
  <div class="bar">
    <div class="left">
      <button id="start" class="on">Start</button>
      <button id="freeze">Freeze</button>
      <button id="fs">Vollbild</button>
      <button id="menu" class="icon" aria-label="Menü">⋯</button>
    </div>
    <div class="right">
      <div class="pill" id="status">Bereit</div>
    </div>
  </div>

  <div class="stage" id="stage">
    <canvas id="out"></canvas>
    <video id="live" playsinline autoplay muted></video>
    <div id="tapTip" class="overlayTip"></div>
  </div>
</div>

<!-- Menü -->
<div class="modalBack" id="menuBack">
  <div class="modal" role="dialog" aria-modal="true" aria-label="Menü">
    <div class="modalHeader">
      <div class="modalTitle">Menü</div>
      <button id="menuClose" class="icon" aria-label="Schließen">✕</button>
    </div>
    <div class="modalBody">

      <div class="row">
        <label for="delay">Delay</label>
        <div class="pill"><b><span id="dLabel">10</span>s</b></div>
      </div>
      <div class="row">
        <input id="delay" type="range" min="1" max="30" value="10" />
      </div>

      <div class="row">
        <label for="quality">Qualität</label>
        <select id="quality">
          <option value="0">Medium (720p)</option>
          <option value="1" selected>Hoch (1080p)</option>
          <option value="2">Ultra (1440p)</option>
        </select>
      </div>

      <div class="row">
        <button id="switchCam" class="smallBtn">Kamera wechseln</button>
        <button id="viewHeat" class="smallBtn">Heatmap ansehen</button>
        <button id="calib" class="smallBtn">Kalibrieren</button>
      </div>

      <div class="row">
        <button id="autoZoomBtn" class="smallBtn">Auto-Zoom: Aus</button>
        <button id="setTargetBtn" class="smallBtn">Ziel wählen</button>
      </div>

      <div class="row">
        <label for="zoom">Zoom</label>
        <input id="zoom" type="range" min="10" max="30" value="14" />
      </div>

      <div class="hint">
        Auto-Zoom: Tippe einmal auf dich im Bild (Ziel). Dann bleibt der Ausschnitt groß.
      </div>

    </div>
  </div>
</div>

<!-- Heatmap -->
<div class="modalBack" id="heatBack">
  <div class="modal" role="dialog" aria-modal="true" aria-label="Heatmap">
    <div class="modalHeader">
      <div class="modalTitle">Heatmap (letzte <span id="heatN">10</span> Würfe)</div>
      <button id="heatClose" class="icon" aria-label="Schließen">✕</button>
    </div>
    <div class="modalBody">
      <div class="heatWrap">
        <canvas id="heatView"></canvas>
      </div>
      <div class="row">
        <button id="clearHeat" class="smallBtn">Zurücksetzen</button>
        <button id="set10" class="smallBtn on">Letzte 10</button>
        <button id="set25" class="smallBtn">Letzte 25</button>
      </div>
      <div class="hint">Tippe auf die Heatmap, um die Animation erneut abzuspielen.</div>
    </div>
  </div>
</div>

<script>
  // ---------- Elements ----------
  const live = document.getElementById('live');
  const out  = document.getElementById('out');
  const ctx  = out.getContext('2d', { alpha:false });
  const stage = document.getElementById('stage');

  const btnStart  = document.getElementById('start');
  const btnFreeze = document.getElementById('freeze');
  const btnFs     = document.getElementById('fs');
  const statusEl  = document.getElementById('status');

  const btnMenu = document.getElementById('menu');
  const menuBack = document.getElementById('menuBack');
  const menuClose = document.getElementById('menuClose');

  const delaySlider = document.getElementById('delay');
  const dLabel = document.getElementById('dLabel');
  const qualitySelect = document.getElementById('quality');
  const btnSwitchCam = document.getElementById('switchCam');

  const btnViewHeat = document.getElementById('viewHeat');
  const btnCalib = document.getElementById('calib');

  const btnAutoZoom = document.getElementById('autoZoomBtn');
  const btnSetTarget = document.getElementById('setTargetBtn');
  const zoomSlider = document.getElementById('zoom');

  const heatBack = document.getElementById('heatBack');
  const heatClose = document.getElementById('heatClose');
  const heatView = document.getElementById('heatView');
  const heatCtx = heatView.getContext('2d', { alpha:false });
  const heatNLabel = document.getElementById('heatN');
  const btnClearHeat = document.getElementById('clearHeat');
  const btnSet10 = document.getElementById('set10');
  const btnSet25 = document.getElementById('set25');

  const tapTip = document.getElementById('tapTip');

  // ---------- Helpers ----------
  function setStatus(t){ statusEl.textContent = t; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function haptic(ms=18){ try{ if (navigator.vibrate) navigator.vibrate(ms); }catch(e){} }

  // ---------- State ----------
  let stream=null, running=false, frozen=false, facing="environment";
  let captureTimer=null;

  // Frame buffer stored as ImageData (works everywhere)
  let frames=[]; // { t:number, img:ImageData }
  let captureCanvas=document.createElement('canvas');
  let captureCtx=captureCanvas.getContext('2d', { willReadFrequently:true });

  const presets=[
    {name:"Medium", w:1280, h:720,  fps:24 },
    {name:"Hoch",   w:1920, h:1080, fps:30 },
    {name:"Ultra",  w:2560, h:1440, fps:30 }
  ];
  function preset(){ return presets[Number(qualitySelect.value)]; }

  function clearFrames(){ frames.length=0; }

  function pickFrameAtOrBefore(targetTime){
    if(!frames.length) return null;
    let lo=0, hi=frames.length-1, best=0;
    while(lo<=hi){
      const mid=(lo+hi)>>1;
      if(frames[mid].t<=targetTime){ best=mid; lo=mid+1; }
      else hi=mid-1;
    }
    return frames[best];
  }

  // ---------- Auto Zoom (digital crop) ----------
  let autoZoomOn=false;
  let zoomFactor=1.4;
  let target=null;      // {x,y} in out coords
  let targetPick=false;

  function updateAutoZoomUI(){
    btnAutoZoom.textContent = autoZoomOn ? "Auto-Zoom: An" : "Auto-Zoom: Aus";
    btnAutoZoom.classList.toggle("on", autoZoomOn);
  }

  zoomFactor = Number(zoomSlider.value)/10;
  zoomSlider.oninput = ()=>{ zoomFactor = Number(zoomSlider.value)/10; };

  btnAutoZoom.onclick=()=>{
    haptic();
    autoZoomOn=!autoZoomOn;
    updateAutoZoomUI();
    if(autoZoomOn && !target){
      targetPick=true;
      setStatus("Tippe auf dich im Bild");
    }
  };
  btnSetTarget.onclick=()=>{
    haptic();
    targetPick=true;
    setStatus("Tippe auf dich im Bild");
  };
  updateAutoZoomUI();

  function drawZoomedImageData(img){
    // draw ImageData to a temp canvas, then draw to output with crop
    captureCanvas.width = img.width;
    captureCanvas.height = img.height;
    captureCtx.putImageData(img, 0, 0);

    if(!autoZoomOn || !target){
      ctx.drawImage(captureCanvas, 0,0, out.width, out.height);
      return;
    }

    const z = zoomFactor;
    const cropW = out.width / z;
    const cropH = out.height / z;

    let sx = target.x - cropW/2;
    let sy = target.y - cropH/2;

    sx = Math.max(0, Math.min(out.width  - cropW, sx));
    sy = Math.max(0, Math.min(out.height - cropH, sy));

    ctx.drawImage(captureCanvas, sx, sy, cropW, cropH, 0, 0, out.width, out.height);
  }

  // ---------- Tracking (simple motion centroid) ----------
  const aW=200, aH=112;
  const aCan=document.createElement('canvas');
  aCan.width=aW; aCan.height=aH;
  const aCtx=aCan.getContext('2d',{willReadFrequently:true});
  let prevGray=null;

  let currentPath=[], holdPathUntil=0, missCount=0;
  const MISS_END_FRAMES=10;

  let throwStore=[], keepLastN=10;

  function resetTracking(){ prevGray=null; missCount=0; currentPath=[]; holdPathUntil=0; }

  function detectBallPointFromImageData(img){
    // Downscale for speed
    // draw img into aCan
    // Use temp canvas (captureCanvas already matches img size sometimes, but we use aCan)
    // Convert by drawImage via captureCanvas to avoid getImageData huge on mobile.
    captureCanvas.width = img.width;
    captureCanvas.height = img.height;
    captureCtx.putImageData(img,0,0);

    aCtx.drawImage(captureCanvas, 0,0, aW,aH);
    const data = aCtx.getImageData(0,0,aW,aH).data;

    const gray=new Uint8Array(aW*aH);
    for(let i=0,j=0;i<data.length;i+=4,j++){
      gray[j]=(data[i]*3 + data[i+1]*4 + data[i+2])>>3;
    }
    if(!prevGray){ prevGray=gray; return null; }

    const TH=22;
    let sumW=0,sumX=0,sumY=0;
    for(let y=0;y<aH;y++){
      const row=y*aW;
      for(let x=0;x<aW;x++){
        const idx=row+x;
        const d=Math.abs(gray[idx]-prevGray[idx]);
        if(d>TH){
          const w=d;
          sumW+=w; sumX+=w*x; sumY+=w*y;
        }
      }
    }
    prevGray=gray;
    if(sumW<14000) return null;

    const cx=sumX/sumW, cy=sumY/sumW;
    return { x:(cx/(aW-1))*out.width, y:(cy/(aH-1))*out.height };
  }

  function finalizeThrow(){
    if(currentPath.length>=6){
      throwStore.push({ points: currentPath.map(p=>({x:p.x,y:p.y})), ts:Date.now() });
      if(throwStore.length>keepLastN) throwStore=throwStore.slice(-keepLastN);
    }
  }

  function processTrackingOnFrame(img){
    const now=Date.now();
    if(holdPathUntil && now<holdPathUntil) return;

    const pt = detectBallPointFromImageData(img);
    if(!pt){
      missCount++;
      if(currentPath.length>10 && missCount>=MISS_END_FRAMES){
        finalizeThrow();
        holdPathUntil=now+3000;
        missCount=0;
      }
      return;
    }

    missCount=0;
    if(holdPathUntil && now>=holdPathUntil){
      currentPath=[]; holdPathUntil=0;
    }

    const last=currentPath[currentPath.length-1];
    const minDist=Math.max(2, Math.min(out.width,out.height)*0.004);
    if(!last || Math.hypot(pt.x-last.x, pt.y-last.y)>minDist){
      currentPath.push({x:pt.x,y:pt.y});
    }
    if(currentPath.length>900) currentPath.shift();
  }

  function drawHoldOverlay(){
    const now=Date.now();
    const holding = holdPathUntil && now<holdPathUntil;
    if(!holding || currentPath.length<2) return;

    ctx.save();
    ctx.lineJoin="round"; ctx.lineCap="round";

    ctx.lineWidth=Math.max(3, Math.min(out.width,out.height)*0.006);
    ctx.strokeStyle="rgba(0,0,0,0.55)";
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x,currentPath[0].y);
    for(let i=1;i<currentPath.length;i++) ctx.lineTo(currentPath[i].x,currentPath[i].y);
    ctx.stroke();

    ctx.lineWidth=Math.max(2, Math.min(out.width,out.height)*0.004);
    ctx.strokeStyle="rgba(255,255,255,0.92)";
    ctx.beginPath();
    ctx.moveTo(currentPath[0].x,currentPath[0].y);
    for(let i=1;i<currentPath.length;i++) ctx.lineTo(currentPath[i].x,currentPath[i].y);
    ctx.stroke();

    ctx.restore();
  }

  // ---------- Calibration ----------
  let calibActive=false, calibPts=[], H=null;
  function showTip(t){ tapTip.textContent=t; tapTip.classList.add('show'); }
  function hideTip(){ tapTip.classList.remove('show'); }

  function computeHomography(src4, dst4){
    const A=[], b=[];
    for(let i=0;i<4;i++){
      const x=src4[i].x, y=src4[i].y;
      const u=dst4[i].x, v=dst4[i].y;
      A.push([x,y,1, 0,0,0, -u*x, -u*y]); b.push(u);
      A.push([0,0,0, x,y,1, -v*x, -v*y]); b.push(v);
    }
    const n=8;
    const M=A.map((row,i)=>row.concat([b[i]]));
    for(let col=0; col<n; col++){
      let pivot=col;
      for(let r=col+1;r<n;r++){
        if(Math.abs(M[r][col])>Math.abs(M[pivot][col])) pivot=r;
      }
      [M[col],M[pivot]]=[M[pivot],M[col]];
      const div=M[col][col]||1e-12;
      for(let c=col;c<=n;c++) M[col][c]/=div;
      for(let r=0;r<n;r++){
        if(r===col) continue;
        const factor=M[r][col];
        for(let c=col;c<=n;c++) M[r][c]-=factor*M[col][c];
      }
    }
    const h=M.map(row=>row[n]);
    return [[h[0],h[1],h[2]],[h[3],h[4],h[5]],[h[6],h[7],1]];
  }
  function applyH(H, x, y){
    const a=H[0][0]*x + H[0][1]*y + H[0][2];
    const b=H[1][0]*x + H[1][1]*y + H[1][2];
    const c=H[2][0]*x + H[2][1]*y + H[2][2];
    return { x:a/c, y:b/c };
  }
  function startCalib(){
    calibActive=true; calibPts=[]; H=null;
    showTip("Kalibrieren: Tippe nah links.");
    closeMenu();
  }

  // ---------- Heatmap ----------
  let heatAnimId=null;

  function resizeHeatCanvas(){
    const cssW = heatView.clientWidth || 600;
    const cssH = heatView.clientHeight || 600;
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.max(320, Math.round(cssW * dpr));
    const h = Math.max(320, Math.round(cssH * dpr));
    if(heatView.width!==w || heatView.height!==h){ heatView.width=w; heatView.height=h; }
  }

  function laneMetrics(){
    // realistic: length/width ~ 17.35
    const R=17.35;
    const topPad=Math.round(heatView.height*0.06);
    const bottomPad=Math.round(heatView.height*0.04);
    const laneH=Math.max(220, heatView.height - topPad - bottomPad);
    const maxW=Math.round(heatView.width*0.82);
    const laneW=Math.max(180, Math.min(maxW, Math.round(laneH / R)));
    const laneX=Math.round((heatView.width - laneW) / 2);
    const laneY=topPad;
    return {laneX,laneY,laneW,laneH};
  }

  function drawLaneBackground(){
    heatCtx.fillStyle="#0a0e13";
    heatCtx.fillRect(0,0,heatView.width,heatView.height);

    const lane=laneMetrics();

    // gutters
    const gutterW=Math.max(10, Math.round(lane.laneW*0.16));
    heatCtx.fillStyle="#070a0f";
    heatCtx.fillRect(lane.laneX - gutterW, lane.laneY, gutterW, lane.laneH);
    heatCtx.fillRect(lane.laneX + lane.laneW, lane.laneY, gutterW, lane.laneH);

    // lane
    heatCtx.fillStyle="#0e141c";
    heatCtx.fillRect(lane.laneX, lane.laneY, lane.laneW, lane.laneH);

    heatCtx.strokeStyle="#223041";
    heatCtx.lineWidth=Math.max(2, Math.round(heatView.width*0.004));
    heatCtx.strokeRect(lane.laneX, lane.laneY, lane.laneW, lane.laneH);

    // boards
    heatCtx.strokeStyle="rgba(255,255,255,0.06)";
    heatCtx.lineWidth=1;
    const boards=39;
    for(let i=1;i<boards;i++){
      const x=lane.laneX + (i/boards)*lane.laneW;
      heatCtx.beginPath();
      heatCtx.moveTo(x,lane.laneY);
      heatCtx.lineTo(x,lane.laneY+lane.laneH);
      heatCtx.stroke();
    }

    // foul line
    const foulY=lane.laneY + lane.laneH*0.86;
    heatCtx.strokeStyle="rgba(255,255,255,0.20)";
    heatCtx.lineWidth=Math.max(2, Math.round(heatView.width*0.006));
    heatCtx.beginPath();
    heatCtx.moveTo(lane.laneX,foulY);
    heatCtx.lineTo(lane.laneX+lane.laneW,foulY);
    heatCtx.stroke();

    // dots
    const dotsY1=lane.laneY + lane.laneH*0.78;
    const dotsY2=lane.laneY + lane.laneH*0.72;
    const dotBoards=[7,13,19,25,31];
    heatCtx.fillStyle="rgba(255,255,255,0.18)";
    const dotR=Math.max(2, Math.round(heatView.width*0.006));
    for(const b of dotBoards){
      const x=lane.laneX + (b/39)*lane.laneW;
      heatCtx.beginPath(); heatCtx.arc(x,dotsY1,dotR,0,Math.PI*2); heatCtx.fill();
      heatCtx.beginPath(); heatCtx.arc(x,dotsY2,dotR,0,Math.PI*2); heatCtx.fill();
    }

    // arrows
    const arrowsY=lane.laneY + lane.laneH*0.64;
    const arrowBoards=[5,10,15,20,25,30,35];
    const aw=lane.laneW*0.05, ah=lane.laneH*0.02;
    heatCtx.fillStyle="rgba(255,255,255,0.16)";
    for(const b of arrowBoards){
      const cx=lane.laneX + (b/39)*lane.laneW;
      heatCtx.beginPath();
      heatCtx.moveTo(cx,arrowsY-ah);
      heatCtx.lineTo(cx-aw/2,arrowsY+ah);
      heatCtx.lineTo(cx+aw/2,arrowsY+ah);
      heatCtx.closePath();
      heatCtx.fill();
    }

    // pin deck line
    const pinDeckY=lane.laneY + lane.laneH*0.10;
    heatCtx.strokeStyle="rgba(255,255,255,0.12)";
    heatCtx.lineWidth=Math.max(1, Math.round(heatView.width*0.004));
    heatCtx.beginPath();
    heatCtx.moveTo(lane.laneX,pinDeckY);
    heatCtx.lineTo(lane.laneX+lane.laneW,pinDeckY);
    heatCtx.stroke();

    // pins correct orientation (headpin lower in cluster)
    const pinCenterX=lane.laneX + lane.laneW*0.50;
    const pinDeckTop=lane.laneY + lane.laneH*0.04;
    const pinDeckBottom=lane.laneY + lane.laneH*0.12;
    const pinDy=(pinDeckBottom - pinDeckTop)/3;
    const pinDx=lane.laneW*0.08;
    const pinR=Math.max(2, Math.round(heatView.width*0.007));
    heatCtx.fillStyle="rgba(255,255,255,0.20)";
    const rows=[[-1.5,-0.5,0.5,1.5],[-1,0,1],[-0.5,0.5],[0]];
    for(let r=0;r<rows.length;r++){
      const y=pinDeckTop + r*pinDy;
      for(const off of rows[r]){
        const x=pinCenterX + off*pinDx;
        heatCtx.beginPath(); heatCtx.arc(x,y,pinR,0,Math.PI*2); heatCtx.fill();
      }
    }

    heatCtx.fillStyle="rgba(154,164,178,0.92)";
    heatCtx.font = `${Math.max(12, Math.round(heatView.width*0.05))}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
    heatCtx.fillText(H ? "Kalibriert" : "Nicht kalibriert", lane.laneX, lane.laneY - Math.max(10, Math.round(heatView.height*0.02)));
    return lane;
  }

  function drawOneThrowTopDown(throwObj, progress01, index, total, lane){
    const pts=throwObj.points;
    if(!pts || pts.length<2) return;
    const age=(total-1-index);
    const alpha=Math.max(0.18, 0.60 - age*0.06);

    heatCtx.save();
    heatCtx.lineJoin="round"; heatCtx.lineCap="round";
    heatCtx.lineWidth=Math.max(2, lane.laneW*0.06);
    heatCtx.strokeStyle=`rgba(255,255,255,${alpha})`;

    const maxK=Math.max(1, Math.floor((pts.length-1)*clamp(progress01,0,1)));
    heatCtx.beginPath();
    for(let k=0;k<=maxK;k++){
      const p=pts[k];
      let uv = H ? applyH(H, p.x, p.y) : {x:p.x/out.width, y:p.y/out.height};
      const u=clamp(uv.x,0,1), v=clamp(uv.y,0,1);
      const x=lane.laneX + u*lane.laneW;
      const y=lane.laneY + v*lane.laneH;
      if(k===0) heatCtx.moveTo(x,y); else heatCtx.lineTo(x,y);
    }
    heatCtx.stroke();
    heatCtx.restore();
  }

  function startHeatAnimation(){
    if(heatAnimId) cancelAnimationFrame(heatAnimId);
    heatAnimId=null;
    resizeHeatCanvas();

    const throws=throwStore.slice(-keepLastN);
    const total=throws.length;
    const msPerThrow=260, msPerLine=420;
    const startT=performance.now();

    function frame(now){
      const lane=drawLaneBackground();
      const elapsed=now-startT;
      const fullCount=Math.min(total, Math.floor(elapsed/msPerThrow));
      for(let i=0;i<fullCount;i++) drawOneThrowTopDown(throws[i],1,i,total,lane);
      const idx=fullCount;
      if(idx<total){
        const p=(elapsed - idx*msPerThrow)/msPerLine;
        drawOneThrowTopDown(throws[idx],p,idx,total,lane);
        heatAnimId=requestAnimationFrame(frame);
      }else heatAnimId=null;
    }
    heatAnimId=requestAnimationFrame(frame);
  }
  heatView.addEventListener('click', ()=>startHeatAnimation());

  // ---------- UI / Modals ----------
  function openMenu(){ menuBack.classList.add('show'); }
  function closeMenu(){ menuBack.classList.remove('show'); }
  btnMenu.onclick=()=>{ haptic(); openMenu(); };
  menuClose.onclick=()=>{ haptic(); closeMenu(); };
  menuBack.addEventListener('click',(e)=>{ if(e.target===menuBack) closeMenu(); });

  function openHeat(){ heatBack.classList.add('show'); heatNLabel.textContent=String(keepLastN); startHeatAnimation(); }
  function closeHeat(){ heatBack.classList.remove('show'); if(heatAnimId) cancelAnimationFrame(heatAnimId); heatAnimId=null; }
  heatClose.onclick=()=>{ haptic(); closeHeat(); };
  heatBack.addEventListener('click',(e)=>{ if(e.target===heatBack) closeHeat(); });

  btnViewHeat.onclick=()=>{ haptic(); closeMenu(); openHeat(); };
  btnCalib.onclick=()=>{ haptic(); startCalib(); };

  dLabel.textContent=delaySlider.value;
  delaySlider.oninput=()=>{ dLabel.textContent=delaySlider.value; };

  btnSet10.onclick=()=>{
    keepLastN=10; btnSet10.classList.add('on'); btnSet25.classList.remove('on');
    if(throwStore.length>keepLastN) throwStore=throwStore.slice(-keepLastN);
    heatNLabel.textContent="10"; startHeatAnimation();
  };
  btnSet25.onclick=()=>{
    keepLastN=25; btnSet25.classList.add('on'); btnSet10.classList.remove('on');
    if(throwStore.length>keepLastN) throwStore=throwStore.slice(-keepLastN);
    heatNLabel.textContent="25"; startHeatAnimation();
  };
  btnClearHeat.onclick=()=>{ haptic(28); throwStore=[]; resetTracking(); startHeatAnimation(); };

  btnSwitchCam.onclick=async()=>{
    haptic();
    facing = (facing==="environment") ? "user" : "environment";
    if(running){ await stopCam(); await startCam(); }
  };

  btnFreeze.onclick=()=>{
    haptic(28);
    frozen=!frozen;
    btnFreeze.classList.toggle('on', frozen);
    btnFreeze.textContent = frozen ? "Weiter" : "Freeze";
    setStatus(frozen ? "Freeze" : (running ? "Läuft" : "Bereit"));
  };

  btnFs.onclick=async()=>{
    haptic();
    try{
      if(!document.fullscreenElement) await stage.requestFullscreen();
      else await document.exitFullscreen();
    }catch(e){ setStatus("Vollbild nicht verfügbar"); }
  };

  // Tap handling: target pick OR calibration
  stage.addEventListener('click', (e)=>{
    const rect=out.getBoundingClientRect();
    const x=(e.clientX-rect.left)*(out.width/rect.width);
    const y=(e.clientY-rect.top )*(out.height/rect.height);

    if(targetPick){
      target={x,y};
      targetPick=false;
      setStatus("Ziel gesetzt");
      return;
    }

    if(!calibActive) return;
    calibPts.push({x,y});
    if(calibPts.length===1) showTip("Tippe nah rechts.");
    else if(calibPts.length===2) showTip("Tippe fern rechts.");
    else if(calibPts.length===3) showTip("Tippe fern links.");
    else if(calibPts.length===4){
      const dst=[{x:0,y:1},{x:1,y:1},{x:1,y:0},{x:0,y:0}];
      H=computeHomography(calibPts,dst);
      calibActive=false;
      hideTip();
      setStatus("Kalibriert");
    }
  });

  // ---------- Camera (FIXED) ----------
  async function stopCam(){
    running=false; frozen=false;
    btnFreeze.classList.remove('on');
    btnFreeze.textContent="Freeze";
    if(captureTimer){ clearInterval(captureTimer); captureTimer=null; }
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    clearFrames();
    setStatus("Bereit");
  }

  async function waitForPlaying(video, timeoutMs=4000){
    const start=performance.now();
    while (video.readyState < 2 || video.paused){
      try{ await video.play(); }catch(e){}
      await new Promise(r=>setTimeout(r, 80));
      if(performance.now()-start > timeoutMs) break;
    }
  }

  async function startCam(){
    const p=preset();
    setStatus("Start…");

    stream = await navigator.mediaDevices.getUserMedia({
      audio:false,
      video:{
        facingMode:{ ideal:facing },
        width:{ ideal:p.w }, height:{ ideal:p.h },
        frameRate:{ ideal:p.fps, max:p.fps }
      }
    });

    live.srcObject=stream;
    live.muted=true;
    live.playsInline=true;

    await new Promise(r=>live.onloadedmetadata=r);
    await waitForPlaying(live, 6000);

    // If video still not providing sizes, fallback
    const vw = live.videoWidth || p.w;
    const vh = live.videoHeight || p.h;

    out.width = vw;
    out.height = vh;

    // capture canvas uses actual video size
    captureCanvas.width = vw;
    captureCanvas.height = vh;

    ctx.imageSmoothingEnabled=true;
    ctx.imageSmoothingQuality="high";

    running=true; frozen=false;
    clearFrames(); resetTracking();
    setStatus("Läuft");

    const interval=Math.max(20, Math.round(1000/p.fps));

    captureTimer=setInterval(()=>{
      if(!running) return;

      // Draw current video frame onto captureCanvas
      try{
        captureCtx.drawImage(live, 0, 0, vw, vh);
        // Extract ImageData (buffer)
        const img = captureCtx.getImageData(0,0,vw,vh);
        frames.push({ t: Date.now(), img });

        const delaySec=Number(delaySlider.value);
        const maxFrames=Math.ceil((delaySec+2)*p.fps);
        while(frames.length>maxFrames) frames.shift();
      }catch(e){
        // If drawImage fails (rare), show useful status once
        setStatus("Kamera-Frame Fehler (Browser)");
      }
    }, interval);

    function drawLoop(){
      if(!running) return;

      if(!frozen){
        const delaySec=Number(delaySlider.value);
        const targetTime=Date.now() - delaySec*1000;
        const f=pickFrameAtOrBefore(targetTime);
        if(f){
          processTrackingOnFrame(f.img);
          drawZoomedImageData(f.img);
          drawHoldOverlay();
        }else{
          // if buffer not ready, draw live directly (no delay yet)
          ctx.drawImage(live,0,0,out.width,out.height);
        }
      }
      requestAnimationFrame(drawLoop);
    }
    requestAnimationFrame(drawLoop);
  }

  btnStart.onclick=async()=>{
    if(running) return;
    haptic(22);
    try{ await startCam(); }
    catch(e){
      console.error(e);
      setStatus("Kamera blockiert / keine Berechtigung");
    }
  };

  window.addEventListener("pagehide", ()=>stopCam());
  setStatus("Bereit");
</script>
</body>
</html>
